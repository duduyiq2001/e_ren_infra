#!/usr/bin/env python3
"""
E-Ren CLI - Development and testing tool for E-Ren Rails app

Commands:
  up [--platform PLATFORM]  Start Docker containers (Rails + Postgres)
  down                      Stop Docker containers
  build [--platform PLATFORM] Rebuild Docker image (run after Dockerfile changes)
  test [file]               Run RSpec tests (optionally specify a file)
  test all                  Run all RSpec tests
  shell                     Open bash shell in Rails container
  logs                      Show Rails container logs

Options:
  --platform PLATFORM       Build for specific platform (arm64, amd64, x86)
                           Default: auto-detect (arm64 on Apple Silicon, amd64 otherwise)

Examples:
  e_ren up                  # Auto-detect platform
  e_ren up --platform amd64 # Force x86_64 (for Windows/Linux teammates)
  e_ren build --platform arm64 # Force ARM (for Apple Silicon)
"""

import subprocess
import sys
import os
import platform

CONTAINER_NAME = "e_ren_rails"
COMPOSE_FILE = os.path.join(os.path.dirname(__file__), "docker-compose.yml")

# Platform mapping
PLATFORM_MAP = {
    'arm64': 'linux/arm64',
    'amd64': 'linux/amd64',
    'x86': 'linux/amd64',
    'x86_64': 'linux/amd64',
}


def run_command(cmd, check=True, capture_output=False):
    """Run a shell command"""
    if capture_output:
        return subprocess.run(cmd, shell=True, capture_output=True, text=True)
    else:
        return subprocess.run(cmd, shell=True, check=check)


def check_container_running():
    """Check if Rails container is running"""
    result = run_command(
        f"docker ps --filter name={CONTAINER_NAME} --format '{{{{.Names}}}}'",
        capture_output=True
    )
    return CONTAINER_NAME in result.stdout


def detect_platform():
    """Auto-detect platform based on host architecture"""
    machine = platform.machine().lower()
    if machine in ['arm64', 'aarch64']:
        return 'linux/arm64'
    else:
        return 'linux/amd64'


def parse_platform_arg(args):
    """Parse --platform flag from args"""
    platform_arg = None
    remaining_args = []

    i = 0
    while i < len(args):
        if args[i] == '--platform' and i + 1 < len(args):
            platform_key = args[i + 1].lower()
            platform_arg = PLATFORM_MAP.get(platform_key, platform_key)
            if not platform_arg.startswith('linux/'):
                platform_arg = f'linux/{platform_arg}'
            i += 2
        else:
            remaining_args.append(args[i])
            i += 1

    return platform_arg or detect_platform(), remaining_args


def build(platform=None):
    """Rebuild Docker image"""
    if platform is None:
        platform = detect_platform()

    print(f"üî® Building E-Ren Docker image for {platform}...")

    # Set DOCKER_DEFAULT_PLATFORM env var
    env_cmd = f"DOCKER_DEFAULT_PLATFORM={platform} docker-compose -f {COMPOSE_FILE} build"
    run_command(env_cmd)
    print("‚úÖ Build complete!")


def up(platform=None):
    """Start containers"""
    if platform is None:
        platform = detect_platform()

    print(f"üöÄ Starting E-Ren containers for {platform}...")

    # Set DOCKER_DEFAULT_PLATFORM env var
    env_cmd = f"DOCKER_DEFAULT_PLATFORM={platform} docker-compose -f {COMPOSE_FILE} up -d --build"
    run_command(env_cmd)
    print("‚úÖ Containers started!")
    print("üì¶ Installing dependencies (this may take a moment on first run)...")
    print("\nüí° Tip: Run 'e_ren test' to run tests or 'e_ren shell' for interactive shell")


def down():
    """Stop containers"""
    print("üõë Stopping E-Ren containers...")
    run_command(f"docker-compose -f {COMPOSE_FILE} down")
    print("‚úÖ Containers stopped!")


def test(args):
    """Run RSpec tests"""
    if not check_container_running():
        print("‚ùå Rails container is not running. Start it with: e_ren up")
        sys.exit(1)

    if args and args[0] == "all":
        test_cmd = "bundle exec rspec"
    elif args:
        test_file = args[0]
        test_cmd = f"bundle exec rspec {test_file}"
    else:
        test_cmd = "bundle exec rspec"

    print(f"üß™ Running tests: {test_cmd}")

    # Ensure test database exists
    run_command(
        f"docker exec {CONTAINER_NAME} bash -c 'RAILS_ENV=test bundle exec rails db:create db:migrate'",
        check=False
    )

    # Run tests and pipe output
    result = run_command(
        f"docker exec -e RAILS_ENV=test {CONTAINER_NAME} {test_cmd}",
        check=False
    )

    sys.exit(result.returncode)


def shell():
    """Open interactive shell"""
    if not check_container_running():
        print("‚ùå Rails container is not running. Start it with: e_ren up")
        sys.exit(1)

    print("üêö Opening shell in Rails container...")
    run_command(f"docker exec -it {CONTAINER_NAME} bash")


def logs():
    """Show container logs"""
    print("üìã Showing Rails container logs...")
    run_command(f"docker-compose -f {COMPOSE_FILE} logs -f rails")


def usage():
    """Show usage information"""
    print(__doc__)
    sys.exit(1)


def main():
    if len(sys.argv) < 2:
        usage()

    command = sys.argv[1]
    args = sys.argv[2:] if len(sys.argv) > 2 else []

    # Parse platform for build/up commands
    if command in ['up', 'build']:
        platform, args = parse_platform_arg(args)
        commands = {
            "up": lambda: up(platform),
            "down": lambda: down(),
            "build": lambda: build(platform),
            "test": lambda: test(args),
            "shell": lambda: shell(),
            "logs": lambda: logs(),
        }
    else:
        commands = {
            "up": lambda: up(),
            "down": lambda: down(),
            "build": lambda: build(),
            "test": lambda: test(args),
            "shell": lambda: shell(),
            "logs": lambda: logs(),
        }

    if command not in commands:
        print(f"‚ùå Unknown command: {command}\n")
        usage()

    try:
        commands[command]()
    except KeyboardInterrupt:
        print("\n\nüëã Interrupted by user")
        sys.exit(130)
    except subprocess.CalledProcessError as e:
        print(f"\n‚ùå Command failed with exit code {e.returncode}")
        sys.exit(e.returncode)


if __name__ == "__main__":
    main()
