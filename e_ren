#!/usr/bin/env python3
"""
E-Ren CLI - Development and testing tool for E-Ren Rails app

Commands:
  up [--platform PLATFORM]  Start Docker containers (Rails + Postgres)
  down                      Stop Docker containers
  build [--platform PLATFORM] Rebuild Docker image (run after Dockerfile changes)
  server                    Start Rails server on http://localhost:3000
  test [args...]            Run RSpec tests (supports all RSpec options)
  shell                     Open bash shell in Rails container
  logs                      Show Rails container logs

Options:
  --platform PLATFORM       Build for specific platform (arm64, amd64, x86)
                           Default: auto-detect (arm64 on Apple Silicon, amd64 otherwise)

Examples:
  e_ren up                  # Auto-detect platform
  e_ren up --platform amd64 # Force x86_64 (for Windows/Linux teammates)
  e_ren build --platform arm64 # Force ARM (for Apple Silicon)

  # Testing examples
  e_ren test                                     # Run all tests
  e_ren test spec/models                         # Run directory
  e_ren test spec/models/user_spec.rb            # Run file
  e_ren test spec/models/user_spec.rb:42         # Run specific line
  e_ren test spec/models/user_spec.rb:42:56      # Run multiple lines
  e_ren test --example "increments counter"      # Run by example name
  e_ren test -e "auto-confirms"                  # Run by example (short)
  e_ren test spec/models --tag focus             # Run directory with tag
  e_ren test prev                                # Re-run previously failed tests
  e_ren test failed                              # Re-run previously failed tests (alias)
  e_ren test --debug spec/models/user_spec.rb:42 # Debug mode (enables binding.pry)
  e_ren test -d spec/models                      # Debug mode (short form)
"""

import subprocess
import sys
import os
import platform
import re
import json

CONTAINER_NAME = "e_ren_rails"
COMPOSE_FILE = os.path.join(os.path.dirname(__file__), "docker-compose.yml")
CACHE_FILE = os.path.join(os.path.dirname(__file__), ".e_ren_test_cache.json")

# Platform mapping
PLATFORM_MAP = {
    'arm64': 'linux/arm64',
    'amd64': 'linux/amd64',
    'x86': 'linux/amd64',
    'x86_64': 'linux/amd64',
}


def run_command(cmd, check=True, capture_output=False):
    """Run a shell command"""
    if capture_output:
        return subprocess.run(cmd, shell=True, capture_output=True, text=True)
    else:
        return subprocess.run(cmd, shell=True, check=check)


def parse_failed_tests(output):
    """Parse RSpec output to extract failed test locations

    RSpec outputs failures like:
      rspec ./spec/models/user_spec.rb:42 # User validations should validate email
    """
    failed_tests = []

    # Pattern matches lines like: rspec ./spec/path/file_spec.rb:123
    pattern = r'rspec\s+(\.\/)?([^\s]+\.rb:\d+)'

    for line in output.split('\n'):
        match = re.search(pattern, line)
        if match:
            # Extract just the file path with line number
            test_location = match.group(2)
            if test_location not in failed_tests:
                failed_tests.append(test_location)

    return failed_tests


def save_test_cache(failed_tests, last_command):
    """Save failed tests to cache file"""
    cache_data = {
        'failed_tests': failed_tests,
        'last_command': last_command
    }

    try:
        with open(CACHE_FILE, 'w') as f:
            json.dump(cache_data, f, indent=2)
    except Exception:
        # Silently fail if cache can't be written
        pass


def load_test_cache():
    """Load failed tests from cache file"""
    try:
        if os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, 'r') as f:
                return json.load(f)
    except Exception:
        pass
    return None


def check_container_running():
    """Check if Rails container is running"""
    result = run_command(
        f"docker ps --filter name={CONTAINER_NAME} --format '{{{{.Names}}}}'",
        capture_output=True
    )
    return CONTAINER_NAME in result.stdout


def detect_platform():
    """Auto-detect platform based on host architecture"""
    machine = platform.machine().lower()
    if machine in ['arm64', 'aarch64']:
        return 'linux/arm64'
    else:
        return 'linux/amd64'


def parse_platform_arg(args):
    """Parse --platform flag from args"""
    platform_arg = None
    remaining_args = []

    i = 0
    while i < len(args):
        if args[i] == '--platform' and i + 1 < len(args):
            platform_key = args[i + 1].lower()
            platform_arg = PLATFORM_MAP.get(platform_key, platform_key)
            if not platform_arg.startswith('linux/'):
                platform_arg = f'linux/{platform_arg}'
            i += 2
        else:
            remaining_args.append(args[i])
            i += 1

    return platform_arg or detect_platform(), remaining_args


def is_windows():
    """Check if running on Windows"""
    return sys.platform.startswith('win')


def run_docker_compose(cmd, platform):
    """Run docker-compose with platform environment variable"""
    if is_windows():
        # Windows: Use subprocess env parameter
        env = os.environ.copy()
        env['DOCKER_DEFAULT_PLATFORM'] = platform
        return subprocess.run(cmd, shell=True, env=env, check=True)
    else:
        # Unix (Mac/Linux): Use shell env var syntax
        env_cmd = f"DOCKER_DEFAULT_PLATFORM={platform} {cmd}"
        return run_command(env_cmd)


def build(platform=None):
    """Rebuild Docker image"""
    if platform is None:
        platform = detect_platform()

    print(f"üî® Building E-Ren Docker image for {platform}...")
    run_docker_compose(f"docker compose -f {COMPOSE_FILE} build", platform)
    print("‚úÖ Build complete!")


def up(platform=None):
    """Start containers"""
    if platform is None:
        platform = detect_platform()

    print(f"üöÄ Starting E-Ren containers for {platform}...")
    run_docker_compose(f"docker compose -f {COMPOSE_FILE} up -d --build", platform)
    print("‚úÖ Containers started!")
    print("üì¶ Installing dependencies (this may take a moment on first run)...")
    print("\nüí° Tip: Run 'e_ren test' to run tests or 'e_ren shell' for interactive shell")


def down():
    """Stop containers"""
    print("üõë Stopping E-Ren containers...")
    run_command(f"docker compose -f {COMPOSE_FILE} down")
    print("‚úÖ Containers stopped!")


def test(args):
    """Run RSpec tests

    Examples:
        e_ren test                                    # Run all tests
        e_ren test spec/models                        # Run directory
        e_ren test spec/models/user_spec.rb           # Run file
        e_ren test spec/models/user_spec.rb:42        # Run specific line
        e_ren test spec/models/user_spec.rb:42:56     # Run multiple lines
        e_ren test --example "increments counter"     # Run by name
        e_ren test -e "auto-confirms"                 # Run by name (short)
        e_ren test --tag focus                        # Run by tag
        e_ren test prev                               # Re-run previously failed tests
        e_ren test failed                             # Re-run previously failed tests
        e_ren test --debug [args]                     # Debug mode (enables binding.pry)
        e_ren test -d [args]                          # Debug mode (short form)
    """
    if not check_container_running():
        print("‚ùå Rails container is not running. Start it with: e_ren up")
        sys.exit(1)

    # Check for debug mode
    debug_mode = False
    if args and args[0] in ['--debug', '-d']:
        debug_mode = True
        args = args[1:]  # Remove debug flag from args

    # Check if user wants to re-run previous failures
    if args and args[0] in ['prev', 'failed']:
        cache = load_test_cache()
        if not cache or not cache.get('failed_tests'):
            print("‚ùå No previously failed tests found. Run tests first to build cache.")
            sys.exit(1)

        failed_tests = cache['failed_tests']
        print(f"üîÑ Re-running {len(failed_tests)} previously failed test(s):")
        for test in failed_tests:
            print(f"   - {test}")
        print()

        rspec_args = ' '.join(failed_tests)
        test_cmd = f"bundle exec rspec {rspec_args}"
    else:
        # Join all arguments to pass through to RSpec
        # This allows line numbers, directories, options, etc.
        if args:
            rspec_args = ' '.join(args)
            test_cmd = f"bundle exec rspec {rspec_args}"
        else:
            test_cmd = "bundle exec rspec"

    if debug_mode:
        print(f"üêõ Running tests in DEBUG mode (binding.pry enabled): {test_cmd}")
    else:
        print(f"üß™ Running tests: {test_cmd}")

    # Ensure test database exists
    run_command(
        f"docker exec {CONTAINER_NAME} bash -c 'RAILS_ENV=test bundle exec rails db:create db:migrate'",
        check=False
    )

    # Run tests
    if debug_mode:
        # Interactive mode for debugging (allows binding.pry to work)
        # Use os.system() instead of subprocess.run() to properly connect stdin
        exit_code = os.system(
            f"docker exec -it -e RAILS_ENV=test {CONTAINER_NAME} {test_cmd}"
        )
        # Don't parse failures in debug mode
        # os.system returns exit code shifted by 8 bits on Unix
        sys.exit(exit_code >> 8 if exit_code > 0 else 0)
    else:
        # Normal mode with output capture for failure parsing
        result = subprocess.run(
            f"docker exec -e RAILS_ENV=test {CONTAINER_NAME} {test_cmd}",
            shell=True,
            capture_output=True,
            text=True
        )

        # Print output
        print(result.stdout)
        if result.stderr:
            print(result.stderr, file=sys.stderr)

        # Parse failed tests and save to cache
        failed_tests = parse_failed_tests(result.stdout + result.stderr)

        if failed_tests:
            save_test_cache(failed_tests, test_cmd)
            print(f"\nüíæ Cached {len(failed_tests)} failed test(s). Run 'e_ren test prev' to re-run them.")
        else:
            # Clear cache if all tests passed
            if os.path.exists(CACHE_FILE):
                os.remove(CACHE_FILE)

        sys.exit(result.returncode)


def shell():
    """Open interactive shell"""
    if not check_container_running():
        print("‚ùå Rails container is not running. Start it with: e_ren up")
        sys.exit(1)

    print("üêö Opening shell in Rails container...")
    run_command(f"docker exec -it {CONTAINER_NAME} bash")


def logs():
    """Show container logs"""
    print("üìã Showing Rails container logs...")
    run_command(f"docker compose -f {COMPOSE_FILE} logs -f rails")


def server():
    """Start Rails server"""
    if not check_container_running():
        print("‚ùå Rails container is not running. Start it with: e_ren up")
        sys.exit(1)

    print("üåê Starting Rails server on http://localhost:3000")
    print("üí° Press Ctrl+C to stop the server\n")
    run_command(f"docker exec -it {CONTAINER_NAME} rails server -b 0.0.0.0")


def usage():
    """Show usage information"""
    print(__doc__)
    sys.exit(1)


def main():
    if len(sys.argv) < 2:
        usage()

    command = sys.argv[1]
    args = sys.argv[2:] if len(sys.argv) > 2 else []

    # Parse platform for build/up commands
    if command in ['up', 'build']:
        platform, args = parse_platform_arg(args)
        commands = {
            "up": lambda: up(platform),
            "down": lambda: down(),
            "build": lambda: build(platform),
            "server": lambda: server(),
            "test": lambda: test(args),
            "shell": lambda: shell(),
            "logs": lambda: logs(),
        }
    else:
        commands = {
            "up": lambda: up(),
            "down": lambda: down(),
            "build": lambda: build(),
            "server": lambda: server(),
            "test": lambda: test(args),
            "shell": lambda: shell(),
            "logs": lambda: logs(),
        }

    if command not in commands:
        print(f"‚ùå Unknown command: {command}\n")
        usage()

    try:
        commands[command]()
    except KeyboardInterrupt:
        print("\n\nüëã Interrupted by user")
        sys.exit(130)
    except subprocess.CalledProcessError as e:
        print(f"\n‚ùå Command failed with exit code {e.returncode}")
        sys.exit(e.returncode)


if __name__ == "__main__":
    main()
